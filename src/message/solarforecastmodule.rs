// SPDX-FileCopyrightText: 2021 Open Energy Solutions Inc
//
// SPDX-License-Identifier: Apache-2.0

// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

use crate::commonmodule::*;
#[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
pub struct SolarForecastPoint {
    // parent_message: false
    // required_field: true
    // multiplicity_min: Some(1)
    // multiplicity_max: None
    // uuid: false
    // key: false
    #[prost(message, optional, tag="1")]
    #[serde(default, rename = "forecastTime")]
    pub forecast_time: ::std::option::Option<super::commonmodule::Timestamp>,
    #[prost(message, optional, tag="2")]
    #[serde(default, rename = "output_ACPower")]
    pub output_ac_power: ::std::option::Option<f32>,
    #[prost(message, optional, tag="3")]
    #[serde(default, rename = "irradiance_GlobalHorizontal")]
    pub irradiance_global_horizontal: ::std::option::Option<f32>,
    #[prost(message, optional, tag="4")]
    #[serde(default, rename = "irradiance_PlaneOfArray")]
    pub irradiance_plane_of_array: ::std::option::Option<f32>,
    #[prost(message, optional, tag="5")]
    #[serde(default, rename = "ambientTempC")]
    pub ambient_temp_c: ::std::option::Option<f32>,
    #[prost(message, optional, tag="6")]
    #[serde(default, rename = "ambientTempF")]
    pub ambient_temp_f: ::std::option::Option<f32>,
}
mod solar_forecast_point {
    use lazy_static::lazy_static;
    lazy_static! {
        pub(super) static ref FORECAST_TIME: crate::commonmodule::Timestamp = Default::default();
        pub(super) static ref OUTPUT_AC_POWER: f32 = Default::default();
        pub(super) static ref IRRADIANCE_GLOBAL_HORIZONTAL: f32 = Default::default();
        pub(super) static ref IRRADIANCE_PLANE_OF_ARRAY: f32 = Default::default();
        pub(super) static ref AMBIENT_TEMP_C: f32 = Default::default();
        pub(super) static ref AMBIENT_TEMP_F: f32 = Default::default();
    }
}
impl SolarForecastPoint {
}
pub trait IsSolarForecastPoint {
    fn _solar_forecast_point(&self) -> &SolarForecastPoint;
    fn _solar_forecast_point_mut(&mut self) -> &mut SolarForecastPoint;
    fn forecast_time(&self) -> &super::commonmodule::Timestamp {
        self._solar_forecast_point().forecast_time.as_ref().unwrap_or(&solar_forecast_point::FORECAST_TIME)
    }
    fn forecast_time_mut(&mut self) -> &mut super::commonmodule::Timestamp {
        self._solar_forecast_point_mut().forecast_time.get_or_insert(Default::default())
    }
    fn output_ac_power(&self) -> &f32 {
        self._solar_forecast_point().output_ac_power.as_ref().unwrap_or(&solar_forecast_point::OUTPUT_AC_POWER)
    }
    fn output_ac_power_mut(&mut self) -> &mut f32 {
        self._solar_forecast_point_mut().output_ac_power.get_or_insert(Default::default())
    }
    fn irradiance_global_horizontal(&self) -> &f32 {
        self._solar_forecast_point().irradiance_global_horizontal.as_ref().unwrap_or(&solar_forecast_point::IRRADIANCE_GLOBAL_HORIZONTAL)
    }
    fn irradiance_global_horizontal_mut(&mut self) -> &mut f32 {
        self._solar_forecast_point_mut().irradiance_global_horizontal.get_or_insert(Default::default())
    }
    fn irradiance_plane_of_array(&self) -> &f32 {
        self._solar_forecast_point().irradiance_plane_of_array.as_ref().unwrap_or(&solar_forecast_point::IRRADIANCE_PLANE_OF_ARRAY)
    }
    fn irradiance_plane_of_array_mut(&mut self) -> &mut f32 {
        self._solar_forecast_point_mut().irradiance_plane_of_array.get_or_insert(Default::default())
    }
    fn ambient_temp_c(&self) -> &f32 {
        self._solar_forecast_point().ambient_temp_c.as_ref().unwrap_or(&solar_forecast_point::AMBIENT_TEMP_C)
    }
    fn ambient_temp_c_mut(&mut self) -> &mut f32 {
        self._solar_forecast_point_mut().ambient_temp_c.get_or_insert(Default::default())
    }
    fn ambient_temp_f(&self) -> &f32 {
        self._solar_forecast_point().ambient_temp_f.as_ref().unwrap_or(&solar_forecast_point::AMBIENT_TEMP_F)
    }
    fn ambient_temp_f_mut(&mut self) -> &mut f32 {
        self._solar_forecast_point_mut().ambient_temp_f.get_or_insert(Default::default())
    }
}
impl IsSolarForecastPoint for SolarForecastPoint {
    fn _solar_forecast_point(&self) -> &SolarForecastPoint {
        self
    }
    fn _solar_forecast_point_mut(&mut self) -> &mut SolarForecastPoint {
        self
    }
}
#[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
pub struct SolarForecastSch {
    // parent_message: false
    // required_field: true
    // multiplicity_min: Some(1)
    // multiplicity_max: None
    // uuid: false
    // key: false
    #[prost(message, repeated, tag="1")]
    #[serde(default, rename = "crvPts")]
    pub crv_pts: ::std::vec::Vec<SolarForecastPoint>,
}
mod solar_forecast_sch {
    use lazy_static::lazy_static;
    lazy_static! {
    }
}
impl SolarForecastSch {
}
pub trait IsSolarForecastSch {
    fn _solar_forecast_sch(&self) -> &SolarForecastSch;
    fn _solar_forecast_sch_mut(&mut self) -> &mut SolarForecastSch;
    fn crv_pts(&self) -> &::std::vec::Vec<SolarForecastPoint> {
        &self._solar_forecast_sch().crv_pts
    }
    fn crv_pts_mut(&mut self) -> &mut ::std::vec::Vec<SolarForecastPoint> {
        &mut self._solar_forecast_sch_mut().crv_pts
    }
}
impl IsSolarForecastSch for SolarForecastSch {
    fn _solar_forecast_sch(&self) -> &SolarForecastSch {
        self
    }
    fn _solar_forecast_sch_mut(&mut self) -> &mut SolarForecastSch {
        self
    }
}
#[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
pub struct SolarForecast {
    #[prost(message, optional, tag="1")]
    #[serde(default, rename = "solarForecastSCH")]
    pub solar_forecast_sch: ::std::option::Option<SolarForecastSch>,
}
mod solar_forecast {
    use lazy_static::lazy_static;
    lazy_static! {
        pub(super) static ref SOLAR_FORECAST_SCH: crate::solarforecastmodule::SolarForecastSch = Default::default();
    }
}
impl SolarForecast {
}
pub trait IsSolarForecast {
    fn _solar_forecast(&self) -> &SolarForecast;
    fn _solar_forecast_mut(&mut self) -> &mut SolarForecast;
    fn solar_forecast_sch(&self) -> &SolarForecastSch {
        self._solar_forecast().solar_forecast_sch.as_ref().unwrap_or(&solar_forecast::SOLAR_FORECAST_SCH)
    }
    fn solar_forecast_sch_mut(&mut self) -> &mut SolarForecastSch {
        self._solar_forecast_mut().solar_forecast_sch.get_or_insert(Default::default())
    }
}
impl IsSolarForecast for SolarForecast {
    fn _solar_forecast(&self) -> &SolarForecast {
        self
    }
    fn _solar_forecast_mut(&mut self) -> &mut SolarForecast {
        self
    }
}
#[derive(Clone, PartialEq, ::prost::Message, serde::Serialize, serde::Deserialize)]
pub struct SolarForecastProfile {
    // parent_message: true
    // required_field: false
    // multiplicity_min: None
    // multiplicity_max: None
    // uuid: false
    // key: false
    #[prost(message, optional, tag="1")]
    #[serde(default, rename = "messageInfo")]
    pub message_info: ::std::option::Option<super::commonmodule::MessageInfo>,
    // parent_message: false
    // required_field: true
    // multiplicity_min: Some(1)
    // multiplicity_max: None
    // uuid: false
    // key: false
    #[prost(message, optional, tag="2")]
    #[serde(default, rename = "solarForecast")]
    pub solar_forecast: ::std::option::Option<SolarForecast>,
}
mod solar_forecast_profile {
    use lazy_static::lazy_static;
    lazy_static! {
        pub(super) static ref MESSAGE_INFO: crate::commonmodule::MessageInfo = Default::default();
        pub(super) static ref SOLAR_FORECAST: crate::solarforecastmodule::SolarForecast = Default::default();
    }
}
impl SolarForecastProfile {
    pub(crate) fn parent(&self) -> &super::commonmodule::MessageInfo {
        self.message_info.as_ref().unwrap_or(&solar_forecast_profile::MESSAGE_INFO)
    }
    pub(crate) fn parent_mut(&mut self) -> &mut super::commonmodule::MessageInfo {
        self.message_info.get_or_insert(Default::default())
    }
}
pub trait IsSolarForecastProfile {
    fn _solar_forecast_profile(&self) -> &SolarForecastProfile;
    fn _solar_forecast_profile_mut(&mut self) -> &mut SolarForecastProfile;
    fn message_info(&self) -> &super::commonmodule::MessageInfo {
        self._solar_forecast_profile().message_info.as_ref().unwrap_or(&solar_forecast_profile::MESSAGE_INFO)
    }
    fn message_info_mut(&mut self) -> &mut super::commonmodule::MessageInfo {
        self._solar_forecast_profile_mut().message_info.get_or_insert(Default::default())
    }
    fn solar_forecast(&self) -> &SolarForecast {
        self._solar_forecast_profile().solar_forecast.as_ref().unwrap_or(&solar_forecast_profile::SOLAR_FORECAST)
    }
    fn solar_forecast_mut(&mut self) -> &mut SolarForecast {
        self._solar_forecast_profile_mut().solar_forecast.get_or_insert(Default::default())
    }
}
impl IsSolarForecastProfile for SolarForecastProfile {
    fn _solar_forecast_profile(&self) -> &SolarForecastProfile {
        self
    }
    fn _solar_forecast_profile_mut(&mut self) -> &mut SolarForecastProfile {
        self
    }
}
impl IsMessageInfo for SolarForecastProfile {
    fn _message_info(&self) -> &super::commonmodule::MessageInfo {
        self.parent()
    }
    fn _message_info_mut(&mut self) -> &mut MessageInfo {
        self.parent_mut()
    }
}
impl IsIdentifiedObject for SolarForecastProfile {
    fn _identified_object(&self) -> &super::commonmodule::IdentifiedObject {
        self.parent().parent()
    }
    fn _identified_object_mut(&mut self) -> &mut IdentifiedObject {
        self.parent_mut().parent_mut()
    }
}
